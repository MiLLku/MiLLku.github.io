
---
title: üó∫Ô∏è Procedurally Generating 2D Tilemaps in Unity
summary:  Design a system to procedurally generate cave-style maps for 2D base-building simulators like Oxygen Not Included and Ratopia using C#, and learn how to replicate maps with seeds and insert specific structures.
date: 2025-10-12
image:
  filename: ONI.jpg
  caption: 'Image Caption: Oxygen Not Included Screenshot'
authors:
  - admin
tags:
  - Featured
  - Portfolio
  - Coding Stories
  - Hugo
  - Markdown
---

## Introduction

One of the core fun factors in 2D base-building simulation games like 'Oxygen Not Included' or 'Ratopia' is the process of exploring and adapting to a new environment each time you play. This experience is made possible by **Procedural Map Generation**. A statically designed map becomes predictable after a few playthroughs, but a procedurally generated map presents new layouts and resource distributions every time, greatly enhancing replay value.

In this post, we'll explore step-by-step how to design and implement a system for generating natural cave-like 2D maps and placing resources using Unity's Tilemap system and C# scripts.

---

## Core Components of the System

The map generation system we'll build is primarily composed of three scripts:

1.  **`MapGenerator.cs`**: The core logic that generates the overall terrain and cave structure of the map using algorithms like Perlin Noise and Cellular Automata.
2.  **`TileResourceSO.cs`**: A ScriptableObject that defines the properties of each tile composing the map, such as dirt, stone, and iron ore (e.g., mining time, dropped items).
3.  **`TileMapController.cs`**: A central manager that takes the map data generated by `MapGenerator`, places the tiles on the actual Unity Tilemap, and handles interactions like player mining.

Now, let's take a closer look at the role and code of each script.

---
### 1. `MapGenerator.cs`: The Architect: Building the World's Foundation

`MapGenerator` is responsible for the first step of procedural map generation. Its role is to create the basic shape of the terrain from an empty space according to specific rules. This process is mainly achieved through two algorithms.

#### 1.1. Perlin Noise

Perlin noise is a widely used algorithm for creating natural-looking randomness. Instead of complete randomness, it generates smooth, continuous noise values, making it effective for representing various natural phenomena like clouds, mountain ranges, and terrain.

In our system, we use Perlin noise to create the initial terrain, deciding which parts of the map to fill with 'walls' (stone) and which to leave as 'empty space'.

```csharp
// MapGenerator.cs
private void GenerateInitialMap()
{
    // Random seed offset to generate a different map each time
    float offsetX = Random.Range(0f, 9999f);
    float offsetY = Random.Range(0f, 9999f);

    for (int x = 0; x < width; x++)
    {
        for (int y = 0; y < height; y++)
        {
            float noiseValue = Mathf.PerlinNoise(
                (float)x / scale + offsetX,
                (float)y / scale + offsetY
            );

            // If the noise value is greater than a threshold, set it as stone; otherwise, empty space
            mapData[x, y] = (noiseValue > threshold) ? TileType.Stone : TileType.Empty;
        }
    }
}
```
#### 1.2. Cellular Automata

A map generated with only Perlin noise can be somewhat rough and have unnatural spots. Cellular Automata is an algorithm where each tile changes its state based on the state of its neighbors. By repeatedly applying simple rules, the entire structure gradually refines into a more natural form, much like living cells.

For example, by repeatedly applying a rule like, "If there are more than 4 walls in the surrounding 8 tiles, I also become a wall; otherwise, I become empty space," isolated tiles disappear, and organic structures like large caves are formed

```csharp
// MapGenerator.cs
private void SmoothMap()
{
    for (int x = 0; x < width; x++)
    {
        for (int y = 0; y < height; y++)
        {
            int neighbourWallTiles = GetSurroundingWallCount(x, y);

            if (neighbourWallTiles > wallCreationThreshold)
                mapData[x, y] = TileType.Stone;
            else if (neighbourWallTiles < wallCreationThreshold)
                mapData[x, y] = TileType.Empty;
        }
    }
}
```

### 2. TileResourceSO.cs: Breathing Life into Tiles with Data
Once the map's structure is complete, we need to define the characteristics of each tile. TileResourceSO utilizes ScriptableObjects to manage the information for each tile‚Äîsuch as dirt, stone, iron ore, copper, etc.‚Äîas asset files.

Separating data and logic this way makes maintenance very easy. Tasks like adding a new type of mineral or changing the mining time of an existing one can be done easily within the Unity Editor without modifying any code.

Typically, a tile would hold information like its durability and the items it drops when broken.

```csharp
[CreateAssetMenu(fileName = "TileProperties", menuName = "Game/TileProperties")]
public class TileResourceSO : ResourceSO
{
    [Header("Tile Attributes")]
    public TileType typeEnum; // Enum for quick lookup
    public TileBase tileBase; // The tile to be displayed on the Unity Tilemap
    
    [Header("Mining Info")]
    [Min(0.1f)] public float miningTime = 2f;
    public int minDrop = 1;
    public int maxDrop = 2;
    public GameObject breakEffectPrefab;
}

public class ResourceSO : ScriptableObject
{
    [SerializeField, HideInInspector] private string id = "";
    public string Id => id;

    [Header("Classification & Display")]
    public ResourceType type;
    public string displayName;
    public Sprite icon;

    [Header("Properties")]
    public List<string> tags = new();
}
```

### 3. TileMapController.cs: The Mediator: Connecting the Map and the Player

TileMapController plays the crucial role of implementing the generated map data into the actual game world and managing all interactions with the player.

Map Initialization: Based on the TileType array generated by MapGenerator, it sets the appropriate TileBase for each position on Unity's Tilemap component, visually rendering the map.

```csharp
// TileMapController.cs
void InitializeMap()
{
    // Generate map data via MapGenerator
    _tileGrid = new TileData[mapWidth, mapHeight];
    for (int x = 0; x < mapWidth; x++)
    {
        for (int y = 0; y < mapHeight; y++)
        {
            TileResourceSO resource = GetTileResourceForGeneration(x, y);
            if (resource != null)
            {
                _tileGrid[x, y] = new TileData(resource);
                tilemap.SetTile(new Vector3Int(x, y, 0), resource.tileBase);
            }
        }
    }
}
```

### 4. Advanced: Techniques for More Diverse Maps

By adding a few techniques to the basic system described so far, you can create a much more vibrant and deep world.

#### 4.1. Mixing Various Tiles and Creating Biomes

A map made of only dirt, stone, and iron ore can be monotonous. You can introduce variations, such as making different minerals appear at different depths or creating a 'volcanic zone' filled with lava in a specific area. This can be implemented by layering multiple Perlin noises or by using the Y-coordinate (depth) as a condition.

```csharp
// TileMapController.cs
TileResourceSO GetTileResourceForGeneration(int x, int y)
{
    // The top is the sky
    if (y >= mapHeight - 5)
    {
        return null;
    }

    // Determine biome based on depth
    // Example: y < 10 is a lava zone
    if (y < 10) 
    {
        // Generate separate noise for the lava zone to place basalt, magma, etc.
        float lavaNoise = Mathf.PerlinNoise(x * 0.2f, y * 0.2f);
        if (lavaNoise > 0.6f) return magmaResource; // Magma tile
        return basaltResource; // Basalt tile
    }

    // Default zone (dirt, stone, iron, etc.)
    float noise = Mathf.PerlinNoise(x * 0.1f, y * 0.1f);
    if (noise > 0.7f) return ironResource;
    if (noise > 0.5f) return stoneResource;
    return dirtResource;
}
```
In this way, you can create oil deposits at certain depths or generate various biomes like ice zones.

#### 4.2. Natural Object Placement via Poisson Disk Sampling

When placing ore veins, special plants, or enemy spawn points on the map, a completely random placement can often result in clumping or awkward distributions.

Poisson Disk Sampling is an algorithm that places points ensuring that each point maintains a minimum distance from others. Using this, you can make resources or important objects appear much more naturally and evenly distributed across the map.

```csharp
// MapGenerator.cs
private void PlaceResources()
{
    // Place copper ore
    // The minimum distance between veins is guaranteed by the copperRadius value
    var copperPoints = PoissonDiskSampling.GeneratePoints(copperRadius, new Vector2(width, height));
    foreach (var point in copperPoints)
    {
        int x = Mathf.FloorToInt(point.x);
        int y = Mathf.FloorToInt(point.y);

        // Place the resource only if the location is a 'Stone' wall
        if (x >= 0 && x < width && y >= 0 && y < height && mapData[x, y] == TileType.Stone)
        {
            mapData[x, y] = TileType.Copper;
        }
    }
    
    // Other resources can be added in the same way
    // var diamondPoints = PoissonDiskSampling.GeneratePoints(diamondRadius, new Vector2(width, height));
}
```
By combining these various techniques, you can create diverse maps.

### Quick Tip : Replicating and Sharing Maps with Seeds
While the core of procedural generation is randomness, sometimes you want to control that randomness. You might use a seed value when you want to play a famous map seed you found online (like in Minecraft), test a bug, or play on the exact same map as a friend.

A computer's 'randomness' is actually pseudo-random. It generates a sequence of numbers based on an initial value called a 'seed'. This means that if the seed value is the same, the sequence and values of the generated random numbers will always be identical. Applying this to map generation allows you to always create the same map from the same seed.

```csharp
// MapGenerator.cs
[Header("Perlin Noise Settings")]
public string seed;
public bool useRandomSeed;

public void GenerateMap()
{
    if (useRandomSeed || string.IsNullOrEmpty(seed))
    {
        seed = Time.time.ToString();
    }
    // Initialize Unity's random state by converting the string seed to an integer hash code
    UnityEngine.Random.InitState(seed.GetHashCode());

    // From now on, all calls to Random.Range() will be generated in the same sequence determined by the seed
    GenerateInitialMap();
}
```
A numeric seed can also be used by changing the data type of seed to int, which can feel more intuitive than a string.
```csharp
[Header("Perlin Noise Settings")]
public int intSeed; // Changed data type
public bool useRandomSeed;

public void GenerateMap()
{
    if (useRandomSeed)
    {
        intSeed = (int)System.DateTime.Now.Ticks;
    }
    UnityEngine.Random.InitState(intSeed);
    GenerateInitialMap();
}
```
